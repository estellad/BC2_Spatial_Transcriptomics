---
title: "spatial analysis"
author: "Daria Buszta"
date: "2022-11-18"
output: html_document
---


Set-up

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r packages}

library(Seurat)
library(pheatmap)
# library(rio)
library(dplyr)
#library(enrichplot)
library(sctransform)
library(ggplot2)
library(patchwork)
library(hdf5r)
library(ggspavis)
library(SpatialExperiment)
library(scater)
library(scran)
library(devtools)
library(SPARK)
library(rhdf5)
library(tidyverse)

#install.packages("patchwork")
#BiocManager::install("hdf5r")
#BiocManager::install("ggspavis")
#BiocManager::install("SpatialExperiment")
#install_github("https://github.com/xzhoulab/SPARK")
#BiocManager::install("rhdf5")
#install.packages("tidyverse")

# Seurat tutorial:
# https://yu-tong-wang.github.io/talk/sc_st_data_analysis_R.html

# SpatialExperiment tutorial
# https://lmweber.org/OSTA-book/

```


Standard spatial transcriptomics analysis pipeline

```{r file downloads}

# VISIUM with Seurat
data <- Load10X_Spatial(
  data.dir = "/home/dbuszta/R/xenium_paper_analysis/spatial_data/CytAssist_FFPE_Human_Breast_Cancer_spatial",
  filename = "filtered_feature_bc_matrix.h5"
)

slide <- Read10X_Image("/home/dbuszta/R/xenium_paper_analysis/spatial_data/CytAssist_FFPE_Human_Breast_Cancer_spatial/spatial")

#dim(x = data)

#slide <- Read10X_Image("/home/dbuszta/R/xenium_paper_analysis/spatial_data/CytAssist_FFPE_Human_Breast_Cancer_spatial/spatial")

# VISIUM with spatialexperiment
#?read10xVisium
#spe <- read10xVisium("/home/dbuszta/R/xenium_paper_analysis/spatial_data/sample/outs",
#                          type = "HDF5",
#                          data = "filtered",
#                          images = "lowres",
#                          load = F)
# when loading, make sure to rename tissue_positions.csv to tissue_positions_list.csv and to delete the column names, otherwise will not work
# this is only the case for some versions of spatialexperiment

```

The most important thing is to not exclude biologically relevant genes so check what's been removed
```{r QC}

# use the ggspavis package to check all sports have been loaded correctly
plotSpots(spe) # can only be used if object is in spatialexperiment

# subset to keep only spots over tissue
spe <- spe[, colData(spe)$in_tissue == TRUE]

# Removing low quality spots before further analysis e.g. due to cell death during library preparation & low mRNA capture efficiency due to inefficient reverse transcription / PCR amplification

# identify mitochondrial genes
# spatialexperiment
is_mito <- grepl("(^MT-)|(^mt-)", rowData(spe)$symbol)
table(is_mito)

# calculate per-spot QC metrics and store in colData
spe <- addPerCellQC(spe, subsets = list(mito = is_mito))
head(colData(spe))

# repeat for the number of expressed features i.e. number of genes with non-zero UMI counts per spot - nFeature
# spatialexperiment
hist(colData(spe)$detected, breaks = 20)

# and the library size, i.e. the total sum of UMI counts per spot - nCount
# spatialexperiment
hist(colData(spe)$sum, breaks = 20)

# seurat, plotting mitochondrial genes, expressed features and the library size
data[["percent.mt"]] <- PercentageFeatureSet(data,
                                             pattern = "^MT-")

VlnPlot(data, 
        features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"),
        pt.size = 0.1, ncol = 3) # spike at low library size...
# nFeature is the number of genes detected in each cell, nCount is the number of molecules in the cell

#plot1 <- FeatureScatter(
#  data, feature1 = "nCount_Spatial", feature2 = "percent.mt") + NoLegend()
#plot2 <- FeatureScatter(
#  data, feature1 = "nCount_Spatial", feature2 = "nFeature_Spatial") +
#  NoLegend()
#plot1 + plot2

# THE FILTERING PARAMETERS
# I decided on 12.5% mt genes but paper goes with 15%
# I decided on lower boundary for nFeatures to be 500 (same as in the paper) and higher to be 11500, paper does not determine the upper limit
# My parameters filtered out 90 cells, paper's parameters remove 153
subset <- subset(data, 
  subset = nFeature_Spatial >= 500 & 
    nFeature_Spatial <=11500 & 
    nCount_Spatial >= 1000 &
    percent.mt < 12.5)

print(paste("Filter out", ncol(data) - ncol(subset), 
            "samples because of the outlier QC metrics, with", ncol(subset),
            "samples left."))

# Re-check plots post filtering 
VlnPlot(subset, 
        features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"),
        pt.size = 0.1, ncol = 3)

# spatialexperiment
qc_lib_size <- colData(spe)$sum <= 1000

plotQC(spe, type = "spots", 
       discard = "qc_lib_size")

qc_detected <- colData(spe)$detected <= 500
qc_detected <- colData(spe)$detected >= 11500

plotQC(spe, type = "spots", 
       discard = "qc_detected_1000")

qc_mito <- colData(spe)$subsets_mito_percent > 12.5

plotQC(spe, type = "spots", 
       discard = "qc_mito")

# number of discarded spots for each metric
apply(cbind(qc_lib_size, qc_detected, qc_mito), 2, sum)

# combined set of discarded spots
discard <- qc_lib_size | qc_detected | qc_mito
table(discard)

# store in object
colData(spe)$discard <- discard

plotQC(spe, type = "spots", 
       discard = "discard")

# filter low-quality spots
spe <- spe[, !colData(spe)$discard]

# if we knew the number of cells per spot, we should plot this over the histogram to make sure that biologically relevant spots are not being removed
# check if discarded spots do not have any obvious spatial pattern that correlates with known biological features - do this for all three categories and at the end, including all the spots to be discarded 

# number of cells per spot, to check for outliers that could indicate problems during cell segmentation
# if the spots have very high cell counts and low numbers of expressed genes it's an indication of a failed experiment

```


```{r Normalisation}

SpatialFeaturePlot(
  subset, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt")) &
  theme(legend.position = "bottom")  

norm <- SCTransform(subset, assay = "Spatial", verbose = FALSE)
names(norm)

# OSTA book recommends using log-normalisation instead
## calculate library size factors
spe <- computeLibraryFactors(spe)

hist(sizeFactors(spe), breaks = 20)

## calculate logcounts and store in object
spe <- logNormCounts(spe)

```


```{r highly variable genes vs. spatially variable genes, OSTA book}

# HVGs are sufficient if the biologically meaningful spatial information in the dataset mainly reflects spatial distributions of major cell types 
# remove mitochondrial genes since are highly expressed but are not biologically relevant in our case

spe <- spe[!is_mito, ]

# fit mean-variance relationship
dec <- modelGeneVar(spe)

# visualize mean-variance relationship
fit <- metadata(dec)
plot(fit$mean, fit$var, 
     xlab = "mean of log-expression", ylab = "variance of log-expression")
curve(fit$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

# select top HVGs
top_hvgs <- getTopHVGs(dec, prop = 0.1)
length(top_hvgs)

# SVGs should be used instead if there are additional important features in the dataset
# methods: SpatialDE, SPARK, SPARK-X
# SPARKX: https://xzhoulab.github.io/SPARK/02_SPARK_Example/
rawcount <- subset@assays$Spatial@counts # sparse count matrix
rawcount[1:5, 1:5]

# extract the coordinates from the rawdata
# look into this as the formatting differs between example and my data
info <- cbind.data.frame(x=as.numeric(sapply(strsplit(colnames(rawcount),split="x"),"[",1)),
                         y=as.numeric(sapply(strsplit(colnames(rawcount),split="x"),"[",2)),
                         total_counts=apply(rawcount,2,sum))
rownames(info) <- colnames(rawcount)

# integrating HVGs and SVGs to generate a combined set of features can improve downstream clustering performance 
# can be combined by concatenating columns of principal components calculated on the set of HVGs and SVGs (excluding overlapping HVGs) and using this for further downstream analyses

```


```{r SVG: SPARK / SPARK-x}
# Finding spatially variable genes

# https://xzhoulab.github.io/SPARK/02_SPARK_Example/
# https://github.com/xzhoulab/SPARK-Analysis/blob/master/analysis/SPARK/breast_cancer.R

# create matrix for the package: gene or feature/row and spot identifier/column for Visium
sp_count <- subset@assays$Spatial@counts

# extract the annotation information for each sample, i.e. location or coordinates
coord_table <- subset@images$slice1@coordinates
location <- cbind.data.frame(coord_table$row, coord_table$col)
rownames(location) <- colnames(sp_count)
location <- as.matrix(location)

# remove mitochondrial genes
mt_idx <- grep("MT-",rownames(sp_count))
if(length(mt_idx)!=0){
    sp_count    <- sp_count[-mt_idx,]
}

# remove genes not expressed in any cells 
null_idx <- which(as.vector(sp_sums_Rcpp(sp_count,rowSums=TRUE))==0)
sp_count <- sp_count[-null_idx,]

# remove cells without any expression 
removed_cell <- which(as.vector(sp_sums_Rcpp(sp_count))==0)
if(length(removed_cell)!=0){
  sp_count <- sp_count[,-removed_cell]
  location <- location[-removed_cell,]
}

# run SPARK-X
?sparkx
# required: sparsematrix, n x d location matrix 
sparkX <- sparkx(sp_count,location,numCores=2,option="mixture")

# output table
output <- sparkX$res_mtest
ordered <- output[order(output$adjustedPval),]
# genes with FDR>0.01
sum(ordered$adjustedPval <= 0.01)


#BiocManager::install("corral")
library(corral)

vst_ct <- var_stabilize(t(sp_count))
sig_vst_ct <- vst_ct[gene_plot, ]
rel_vst_ct <- apply(sig_vst_ct, 1, relative_func)

```


```{r Dimensionality reduction}

obj <- RunPCA(norm, assay = "SCT", verbose = FALSE)
obj <- FindNeighbors(obj, reduction = "pca", dims = 1:30)
obj <- FindClusters(obj, verbose = FALSE)
obj <- RunUMAP(obj, reduction = "pca", dims = 1:30)
obj <- RunTSNE(obj, reduction = "pca", dims = 1:30)

plot3 <- DimPlot(obj, reduction = "tsne", label = TRUE) + NoLegend()
plot4 <- SpatialDimPlot(obj, label = TRUE, label.size = 3) + NoLegend()
plot3 + plot4

# Spatially aware clustering

# Marker genes

```


DECONVOLUTION

For each method, check the requirements of the data used to build the reference, i.e. post normalisation / QC or in the original state

Deconvolution with spacexr + C-SIDE
 spacexr package for learning cell type-specific differential expression from ST data
   1. RCTD to assign cell types
   2. Test DE across multiple regions

  https://raw.githack.com/dmcable/spacexr/master/vignettes/visium_full_regions.html
  https://www.10xgenomics.com/resources/analysis-guides/integrating-10x-visium-and-chromium-data-with-r (the most helpful tutorial)
  https://github.com/dmcable/spacexr

```{r set-up}

#install.packages("devtools")
library(devtools)

#devtools::install_github("dmcable/spacexr", build_vignettes = FALSE)
library(spacexr)

library(Matrix)
library(doParallel)
library(ggplot2)

datadir <- "/home/dbuszta/R/xenium_paper_analysis/spatial_data/CytAssist_FFPE_Human_Breast_Cancer_spatial/spatial"
?system.file
if(!dir.exists(datadir))
  dir.create(datadir)
savedir <- 'RCTD_results'
if(!dir.exists(savedir))
  dir.create(savedir)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = TRUE,
  out.width = "100%"
)

```


```{r Preprocessing - Visium + Chromium, creating a reference object}

# Read in spatial data: tissue_positions.csv file and the h5 matrix
#vis_coords <- read.csv("/home/dbuszta/R/xenium_paper_analysis/spatial_data/CytAssist_FFPE_Human_Breast_Cancer_spatial/spatial/tissue_positions.csv",
#                       header = T)
#head(vis_coords)

# to  match orientation of the tissue on the slide with spacexr result plots we flip and mirror the coordinates
#vis_coords[,3] <- vis_coords[,3]*-1
#vis_coords[,4] <- vis_coords[,4]*-1
#head(vis_coords)

#resave file
#write.table(vis_coords, '/home/dbuszta/R/xenium_paper_analysis/spatial_data/CytAssist_FFPE_Human_Breast_Cancer_spatial/spatial/tissue_positions.csv', quote=FALSE, row.names=FALSE, sep=',')

#read.VisiumSpatialRNA() to read in the visium data
VisiumData <-read.VisiumSpatialRNA("/home/dbuszta/R/xenium_paper_analysis/spatial_data/CytAssist_FFPE_Human_Breast_Cancer_spatial")

# Examine the object
hist(log(VisiumData@nUMI,2))

#Create a list of barcodes 
barcodes <- colnames(VisiumData@counts)

# Plot number of UMIs per barcode (spot)
plot_puck_continuous(puck=VisiumData, barcodes=barcodes, plot_val=VisiumData@nUMI, 
                     size=1, ylimit=c(0,round(quantile(VisiumData@nUMI,0.9))), 
                     title='plot of nUMI') 


#####
# Load and format single cell data: h5 matrix
Counts <- Read10X_h5("/home/dbuszta/R/xenium_paper_analysis/FFPE_data/Chromium_FFPE_Human_Breast_Cancer_Chromium_FFPE_Human_Breast_Cancer_count_sample_filtered_feature_bc_matrix.h5")

## counts 
count_SeuratObject <- CreateSeuratObject(Counts)
sc_counts <- count_SeuratObject@assays$RNA@counts

## nUMI
head(count_SeuratObject@meta.data)
sc_umis <- count_SeuratObject@meta.data[,c(1,2)] # Format for spacexr
sc_umis <- setNames(sc_umis[[2]], rownames(sc_umis)) # Set object names as nCount_RNA and barcode

# Annotation
cell_types <- import("/home/dbuszta/R/xenium_paper_analysis/FFPE_data/FFPE_cell_annotations.csv")
unique(cell_types$Annotation) # check unique cell types
table(cell_types$Annotation) # spacexr requires at least 25 cells per cell type

# format object for spacexr
cell_types <- setNames(cell_types[[2]], cell_types[[1]])
cell_types <- as.factor(cell_types) 
head(cell_types)

# single cell reference object
SCreference <- Reference(sc_counts, cell_types, sc_umis)
print(dim(SCreference@counts))
table(SCreference@cell_types)

```


```{r - RCTD - Visium + Chromium}

library(spacexr)

## Use RCTD in full mode as it can discover any number of cell types per pixel, 
## hence a good choice for Visium which has a resolution higher than single cells

# run RCTD
Sys.setenv("OPENBLAS_NUM_THREADS"=2)

myRCTD <- create.RCTD(VisiumData, SCreference, max_cores = 2)
myRCTD <- run.RCTD(myRCTD, doublet_mode = "full") # takes a while to run

# create output directory
resultsdir <- "RCTD_output_plots/"
dir.create(resultsdir) 

# Create variables from the myRCTD object to plot results
barcodes <- colnames(myRCTD@spatialRNA@counts) # list of spatial barcodes
weights <- myRCTD@results$weights # weights for each cell type per barcode

# Normalize per spot weights so cell type probabilities sum to 1 for each spot
norm_weights <- normalize_weights(weights) # For each spot barcode (row), you can see the normalized weight for each cell type (column)
cell_type_names <- colnames(norm_weights) # List of cell types
#dim(norm_weights) # matrix of 4,988 spots and 19 cell types

# Look at cell type normalized weights for 2 spots
subset_df <- as.data.frame(t(as.data.frame(norm_weights[1:2,])))
subset_df$celltypes <- rownames(subset_df); rownames(subset_df) <- NULL
subset_df[order(subset_df$`AACACCTACTATCGAA-1`, decreasing=T),]

# Plot cell type probabilities (normalized) per spot (red = 1, blue = 0 probability)
# Save each plot as a jpg file
for(i in 1:length(cell_type_names)){
   plot_puck_continuous(myRCTD@spatialRNA, barcodes, norm_weights[,cell_type_names[i]], title=cell_type_names[i], size=1)
   ggsave(paste(resultsdir, cell_type_names[i],'_weights.jpg', sep=''), height=5, width=5, units='in', dpi=300)
}

# same as above, uses a pdf format instead
spacexr::plot_weights_unthreshold(cell_type_names, myRCTD@spatialRNA, resultsdir, norm_weights) 

# Plot the number of confident pixels of each cell type in "full mode"
plot_cond_occur(cell_type_names, resultsdir, norm_weights, myRCTD@spatialRNA)

```


```{r - C-SIDE - Visium + Chromium}
# C-SIDE: identifies cell type specific differential expression across a general design matrix of covariates. 

# Create an explanatory variable used for predicting differential expression in CSIDE
set.seed(12345)
explanatory.variable <- runif(length(myRCTD@spatialRNA@nUMI))
names(explanatory.variable) <- names(myRCTD@spatialRNA@nUMI) # currently random explanatory variable 
print(head(explanatory.variable))

# Differentially upregulate one gene
myRCTD@spatialRNA@counts@Dimnames[[1]] # find genes
change_gene <- 'PIK3CD'
high_barc <- names(explanatory.variable[explanatory.variable > 0.5])
low_barc <- names(explanatory.variable[explanatory.variable < 0.5])
myRCTD@originalSpatialRNA@counts[change_gene, high_barc] <- myRCTD@spatialRNA@counts[change_gene, high_barc] * 3 

plot_puck_continuous(myRCTD@spatialRNA, names(explanatory.variable), explanatory.variable, ylimit = c(0,1), title ='plot of explanatory variable') 

# Run CSIDE
myRCTD@config$max_cores <- 2
myRCTD <- run.CSIDE.single(myRCTD, explanatory.variable, gene_threshold = .00005, 
                        cell_type_threshold = 125, fdr = 0.01, doublet_mode = F)

savedir <- "CSIDE_plots"
dir.create(savedir)
saveRDS(myRCTD,file.path(savedir,'myRCTDde.rds'))

# Exploring the outputs
cell_type <- 'DCIS 1'
results_de <- myRCTD@de_results$sig_gene_list[[cell_type]]
print(results_de)

make_all_de_plots(myRCTD, savedir)

```


```{r Preprocessing - Xenium binned + Chromium}

# renamed spotbinned_xenium_transcripts_20221024.hd to filtered_feature_bc_matrix.h5 to make downstream steps run smoothly
# binning done by Antoine, https://github.com/antoinegirardin/xenium/blob/main/datareview.R, section '## Xenium to Visium'

h5 <- h5read("/home/dbuszta/R/xenium_paper_analysis/BinnedXenium/filtered_feature_bc_matrix.h5", "/")
#h5_x <- h5read("/home/dbuszta/R/xenium_paper_analysis/spatial_data/Xenium_FFPE_Human_Breast_Cancer_Rep1_outs/outs/cell_feature_matrix.h5", "/")
# dimensions are 301 x 4992 (visium is 18,085 x 4992 and xenium raw is 541 (315 being actual features, the rest are controls) x 167780)

# Xenium data
root_path = "/home/dbuszta/R/xenium_paper_analysis/spatial_data/Xenium_FFPE_Human_Breast_Cancer_Rep1_outs/"
Xenium.data <- Seurat::Read10X(data.dir = paste0(root_path, "outs/", "cell_feature_matrix/"))

Xenium.data <-read.VisiumSpatialRNA("/home/dbuszta/R/xenium_paper_analysis/BinnedXenium")

## counts
#Xenium_Seurat <- CreateSeuratObject(counts = Xenium.data$`Gene Expression`)
#Xenium_Seurat <- SeuratObject::CreateFOV(coords_x)
sc_counts_x <- Xenium.data@counts

## barcodes 
barcodes_x <- colnames(sc_counts_x)

# Plot number of UMIs per barcode (spot)
plot_puck_continuous(puck=Xenium.data, barcodes=barcodes_x, plot_val=Xenium.data@nUMI, 
                     size=1, ylimit=c(0,round(quantile(Xenium.data@nUMI,0.9))), 
                     title='plot of nUMI') 

# used the SCreference created three blocks above
```


```{r}
#root_path = "/home/dbuszta/R/xenium_paper_analysis/spatial_data/Xenium_FFPE_Human_Breast_Cancer_Rep1_outs/"
#Xenium.data <- Seurat::Read10X(data.dir = paste0(root_path, "outs/", "cell_feature_matrix/"))
#Xenium.data <- LoadXenium("/home/dbuszta/R/xenium_paper_analysis/Xenium_FFPE_Human_Breast_Cancer_Rep2_outs/outs")
#Xenium <- Xenium.data@assays$Xenium

#saveRDS(Xenium.data, "/home/dbuszta/Desktop/files_for_cytospace/Xenium/seu_xenium.rds")

#source("/home/dbuszta/R/xenium_paper_analysis/generate_cytospace_from_seurat_object.R")

#generate_cytospace_from_ST_seurat_object(Xenium,
#                                            dir_out='/home/dbuszta/Desktop/files_for_cytospace/Xenium')

# Binned Xenium
binned <- Read10X_h5("/home/dbuszta/R/xenium_paper_analysis/BinnedXenium/filtered_feature_bc_matrix.h5")

#a = as.data.frame(as.matrix(binned))
#export(a, "/home/dbuszta/Desktop/files_for_cytospace/Binned_Xenium/ST.txt")
a <- tibble::rownames_to_column(a, "V1")
write.table(a, "xenium_binned", row.names = F, sep='\t', quote = F)

scseu <- readRDS("/home/dbuszta/Desktop/files_for_cytospace/seu_sctransformed_filtered.rds")
scseu_sctransformed_filtered <- scseu[rownames(scseu) %in% rownames(a)]

saveRDS(scseu, "/home/dbuszta/Desktop/files_for_cytospace/Binned_Xenium/seu_sctransformed_filtered_300genes.rds")

```


```{r Cell Anotations from Chromium on Xenium data}

# Chromium - cell annotations 
cell_types2 <- import("/home/dbuszta/R/xenium_paper_analysis/FFPE_data/FFPE_cell_annotations.csv")
cell_types2 <- cell_types2 %>% remove_rownames %>% column_to_rownames(var = "Barcode")
length(unique(cell_types2$Annotation)) # 19 different annotations identified
sum(is.na(cell_types2$Annotation)) # no NA values found

# Chromium - tsne
seu <- readRDS("seu_sctransformed.rds")

# Linear dimensional reduction 
seu <- RunPCA(seu, verbose = FALSE)

# proceeding with 16 PCAs for further analysis
seu <- FindNeighbors(seu, dims = 1:50, verbose = FALSE)
# changing dims will show different numbers of pca plots
seu <- FindClusters(seu, resolution = 0.3, verbose = FALSE)

# paper uses the top 50 PCAs, redo with those parameters

# pick the resolution that returns 19 clusters, to match those from Chromium
seu <- RunTSNE(seu, reduction = "pca", dims = 1:50)
current.cluster.ids <- c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18)
new.cluster.ids <- c("T cells",
                     "Stromal",
                     "T cells/+Tumour hybrid",
                     "DCIS 1",
                     "Macrophages 1",
                     "Invasive tumour",
                     "B cells",
                     "Invasive tumour x2",
                     "B cells x2",
                     "Myoepi ACTA2+",
                     "Macrophages 2",
                     "Endothelial",
                     "Myoepi KRT15+",
                     "Stromal & T Cell Hybrid",
                     "Macrophages 1 x2",
                     "Perivascular-Like",
                     "IRF7+ DCs",
                     "Endothelial x2",
                     "Mast cells")

names(x = new.cluster.ids) <- levels(x = seu)
cell_annotations <- RenameIdents(object = seu, new.cluster.ids)
DimPlot(cell_annotations, reduction = "tsne", pt.size = 0.1, label = T)

# tracking individual cells back to the clusters
# 1. creating a dataframe to store all information 
cells_to_cluster <- cell_annotations@meta.data
cells_to_cluster <- cbind(cells_to_cluster, annotations = NA) 
cells_to_cluster <- data.frame(cells_to_cluster[,8:9])

# 2. match the strings and add annotation to cells_to_cluster df
for (i in rownames(cells_to_cluster)){
  for (b in rownames(cell_types2)){
    if(i == b){
      cells_to_cluster[i, "annotations"] <- paste(cell_types2[b,"Annotation"])
    }
  }
}

# 3. get rid of na values, these are cells filtered out in my normalisation steps and not in theirs
#cells_to_cluster_nona <- cells_to_cluster[complete.cases(cells_to_cluster$annotations),]

# 4. find out which cluster represents which annotation
# calculate the proportion of rows corresponding to each cell type per cluster
cells_to_cluster_nona$seurat_clusters <- as.numeric(cells_to_cluster_nona$seurat_clusters)
length(unique(cells_to_cluster_nona$seurat_clusters))
subset(cells_to_cluster_nona, cells_to_cluster_nona$seurat_clusters == 6) %>% group_by(annotations) %>% tally()

# according to annotations (16 PCAs) / same for 50 PCAs
# Cluster 1: CD4+ T cells (1569)/ CD8+ T cells (1287)
# Cluster 2: Stromal (2163)
# Cluster 3: CD4+ T cells (1139) / T cell & Tumour hybrid (674)
# Cluster 4: DCIS 1 (1214)
# Cluster 5: Macrophages 1 (2018)
# Cluster 6: Invasive tumour (1386)
# Cluster 7: B cells (250)
# Cluster 8: Invasive tumour (997)
# Cluster 9: B cells (1007)
# Cluster 10: Myoepi ACTA2+ (839)
# Cluster 11: Macrophages 2 (703)
# Cluster 12: Endothelial (650)
# Cluster 13: Myoepi KRT15+ (357)
# Cluster 14: Stromal & T Cell Hybrid (289)
# Cluster 15: Macrophages 1 (259)
# Cluster 16: Perivascular-Like (246)
# Cluster 17: IRF7+ DCs (185)
# Cluster 18: Endothelial (158)
# Cluster 19: Mast cells (90)

# clusters which hadn't been picked up: DCIS 2, Prolif invasive tumour, T cell & Tumour hybrid, LAMP3+ DCs, CD8+ T cells 


# according to gene markers
de_genes <- FindAllMarkers(seu, min.pct = 0.25, only.pos = TRUE)

dittoSeq::dittoDotPlot(seu, vars = unique(top10$gene))

# Cell annotation
de_genes %>%
  group_by(cluster) %>%
  top_n(n = 20, wt = avg_log2FC) -> top20

de_genes %>% filter(gene == "C1QA")

# determine clusters on genes being expressed
# Cluster 1: CD4+ T cells 
# Cluster 2: inflammed environment, contains neutrophils and cancer-related genes
# Cluster 3: Macrophages 2
# Cluster 4: Myoepi ACTA2+
# Cluster 5: CD8+ T cells
# Cluster 6: 
# Cluster 7: 
# Cluster 8: 
# Cluster 9: B cells
# Cluster 10:
# Cluster 11: 
# Cluster 12: Myoepi KRT15+ 
# Cluster 13: 
# Cluster 14: 
# Cluster 15: 
# Cluster 16: 
# Cluster 17: 
# Cluster 18: 
# Cluster 19: 



# check if my preprocessing steps were too strict and got rid of actual biologically relevant cells

# summarise genes per cluster
# Cluster 1: 
# Cluster 2: 
# Cluster 3: 
# Cluster 4: 
# Cluster 5: 
# Cluster 6: 
# Cluster 7: 
# Cluster 8: 
# Cluster 9: 
# Cluster 10:
# Cluster 11: 
# Cluster 12: 
# Cluster 13: 
# Cluster 14: 
# Cluster 15: 
# Cluster 16: 
# Cluster 17: 
# Cluster 18: 
# Cluster 19: 

# check if marker genes are present in xenium's panel
# 3130 unique de genes from visium
visium_genes <- unique(de_genes$gene)
# 301 genes in xenium panel
xenium_genes <- Xenium.data@counts@Dimnames[[1]]
# which of the xenium genes arein the differentially expressed genes from visium?
boolean <- xenium_genes %in% visium_genes
overlap_genes <- xenium_genes[boolean]
# which genes coorespond to which clusters  

# annotate xenium at a single cell level

```


```{r - CSIDE - Xenium + Chromium}

# run RCTD
Sys.setenv("OPENBLAS_NUM_THREADS"=2)

myRCTD <- create.RCTD(Xenium.data, SCreference, max_cores = 2)
myRCTD <- run.RCTD(myRCTD, doublet_mode = "full") # takes a while to run

# create output directory
resultsdir <- "RCTD_output_plots_X/"
dir.create(resultsdir) 

# Create variables from the myRCTD object to plot results
barcodes <- colnames(myRCTD@spatialRNA@counts) # list of spatial barcodes
weights <- myRCTD@results$weights # weights for each cell type per barcode

# Normalize per spot weights so cell type probabilities sum to 1 for each spot
norm_weights <- normalize_weights(weights) # For each spot barcode (row), you can see the normalized weight for each cell type (column)
cell_type_names <- colnames(norm_weights) # List of cell types
#dim(norm_weights) # matrix of 4,988 spots and 19 cell types

# Look at cell type normalized weights for 2 spots
subset_df <- as.data.frame(t(as.data.frame(norm_weights[1:2,])))
subset_df$celltypes <- rownames(subset_df); rownames(subset_df) <- NULL
subset_df[order(subset_df$`AACACGTGCATCGCAC-1`, decreasing=T),]

# Plot cell type probabilities (normalized) per spot (red = 1, blue = 0 probability)
# Save each plot as a jpg file
for(i in 1:length(cell_type_names)){
   plot_puck_continuous(myRCTD@spatialRNA, barcodes, norm_weights[,cell_type_names[i]], title=cell_type_names[i], size=1)
   ggsave(paste(resultsdir, cell_type_names[i],'_weights.jpg', sep=''), height=5, width=5, units='in', dpi=300)
}

# same as above, uses a pdf format instead
# spacexr::plot_weights_unthreshold(cell_type_names, myRCTD@spatialRNA, resultsdir, norm_weights) 

# Plot the number of confident pixels of each cell type in "full mode"
plot_cond_occur(cell_type_names, resultsdir, norm_weights, myRCTD@spatialRNA)

```


To create a reference with Xenium either use the cluster descriptions to annotate the data or integrate Chromium and Xenium to get that information first!
```{r Preprocessing - Visium + Xenium, creating a reference object}

# We are able to map Xenium to Visium so knowing the information of each cell or the cells per a particular spot would be helpful. 

# Visium data
VisiumData

# Xenium data
Xenium_Seurat

# redo cell types for Xenium, if can't find it provided, do analysis and reasign

## nUMI
sc_umis_x <- Xenium_Seurat@meta.data[,c(1,2)] # Format for spacexr
sc_umis_x <- setNames(sc_umis_x[[2]], rownames(sc_umis_x)) # Set object names as nCount_RNA and barcode

# format object for spacexr


# need each transcript to be linked to a cell type to allow deconvolution pipeline
# can i find this information within the Seurat object and add it to recreate the reference requirements?

# gene name information:
SCreference <- Reference(sc_counts_x, cell_types, sc_umis_x)

names(cell_types) 
colnames(counts) # this is null!


cell_types_x <- setNames(cell_types[[2]], cell_types[[1]])
cell_types <- as.factor(cell_types) 
head(cell_types)

# single cell reference object for Xenium
SCreference_X <- Reference(sc_counts, cell_types, sc_umis)
print(dim(SCreference@counts))
table(SCreference@cell_types)

```


```{r Deconvolution with STdeconvolve}
# satisfied with spacexr, will stick with it for now

# https://www.youtube.com/watch?v=bipLp-0vi7c
# https://jef.works/blog/2022/05/03/deconvolution-vs-clustering/
```


```{r SpotClean adjusts for spot swapping in spatial trascriptomics data}
# https://www.biorxiv.org/content/10.1101/2021.06.11.448105v3.full

```

OSTA recommends VistoSeg but also look through Squidpy's Cellpose (seen in Cosmx paper), best if we have 4 immunofluorescence channels available
This is useful for QC as allows benchmarking of UMIs and features across the spots
```{r - counting cells inside the spots}

```


```{r Xenium not binned}
library(Seurat)
#library(feature)

xenium.obj <- LoadXenium("/home/dbuszta/R/xenium_paper_analysis/Xenium_FFPE_Human_Breast_Cancer_Rep2_outs/outs")
xenium.obj <- subset(xenium.obj, subset = nCount_Xenium > 0)

ImageFeaturePlot(xenium.obj, features = c("ABCC11", "ACTA2"), size = 0.5, blend=TRUE)

?ImageFeaturePlot

#xenium.obj@assays$Xenium@counts@Dimnames
```


```{r}
a = import("/home/dbuszta/Desktop/files_for_cytospace/Coordinates.txt")
b = import("/home/dbuszta/Desktop/files_for_cytospace/Binned_Xenium/coords_xenium.txt")
c = import("/home/dbuszta/Desktop/files_for_cytospace/Binned_Xenium/xenium_binned.txt")
d = import("/home/dbuszta/Desktop/files_for_cytospace/Binned_Xenium/scRNA_data_300genes.txt")
e = import("/home/dbuszta/Desktop/files_for_cytospace/Binned_Xenium/annotations_filtered.txt")

# filter xenium and sc files to contain only matching genes, 

head(c)
head(d)
xenium_panel = c$V1 
sc_filtered = d %>% filter(GENES %in% xenium_panel)
xenium_filtered = c %>% filter(V1 %in% sc_filtered$GENES)

#make sure to save in a correct format
# write out the dimensions of all dfs to make sure it makes sense!
dim(b) # 4992 3
head(b)
b = b %>% rename("V1"="SpotID",
                 "V2"="row",
                 "V3"="col")
#write.table(b, file = "/home/dbuszta/Desktop/files_for_cytospace/Binned_Xenium/coords_xenium.txt",row.names = F, sep='\t', quote = F)

dim(e) # 21419 2
head(e)
e = e %>% rename("Cells"="Cell IDs",
                 "Labels"="CellType")
#write.table(e, file = "/home/dbuszta/Desktop/files_for_cytospace/Binned_Xenium/annotations_filtered.txt",row.names = F, sep='\t', quote = F)

dim(sc_filtered) # 300 21420
head(sc_filtered)
#write.table(sc_filtered, file = "/home/dbuszta/Desktop/files_for_cytospace/Binned_Xenium/scRNA_data_300genes.txt",row.names = F, sep='\t', quote = F)

dim(xenium_filtered) # 300 4993
head(xenium_filtered)
#write.table(xenium_filtered, file = "/home/dbuszta/Desktop/files_for_cytospace/Binned_Xenium/xenium_binned.txt",row.names = F, sep='\t', quote = F)

```


```{r - comparing the xenium and visium cytospace input files trying to figure out where it's breaking}
# visium
a <- import("/home/dbuszta/Desktop/files_for_cytospace/ST_data.txt")

# xenium
b <- import("/home/dbuszta/Desktop/files_for_cytospace/Binned_Xenium/xenium_binned.txt")

```

